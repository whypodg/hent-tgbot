import asyncio
import datetime
import hmtai
import html
import logging
import random
import requests

import pyrogram
import pyrogram_patch
from pyrogram import filters, types
from pyrogram_patch.router import Router

import utils
from utils import keyboards as kbs


arts = Router()
arts.name = "arts"


async def getScrolller(query: str):
	ans = requests.get(
		"https://api.scrolller.com/api/v2/graphql",
		json={
			"query": " query SubredditQuery( $url: String! $filter: SubredditPostFilter" \
					 " $iterator: String ) { getSubreddit(url: $url) { children(" \
					 " limit: 1 iterator: $iterator filter: $filter" \
					 " disabledHosts: null ) { iterator items {url subredditTitle" \
					 " isNsfw mediaSources { url } } } } } ",
			"variables": {"url": query, "filter": None, "hostsDown": None},
			"authorization": None
		}
	).json()

	posts = ans['data']['getSubreddit']['children']['items']
	return [post['mediaSources'][-1]['url'] for post in posts]



@arts.on_message(
	filters.command(commands=["hentai", "—Ö–µ–Ω—Ç–∞–π"], prefixes=["/", "!"])
)
async def hentai(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	r = requests.get("https://api.waifu.im/search/?included_tags=hentai").json()

	await m.delete()
	await utils.answer_photo(
		message, r['images'][0]['url'],
		"<i>–º–º–º ü§§</i>", reply_markup=kbs.kb_hent,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("hentai"))
async def hentaiCB(client: pyrogram.Client, query: types.CallbackQuery):
	r = requests.get("https://api.waifu.im/search/?included_tags=hentai").json()
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=r['images'][0]['url'], has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–º–º–º ü§§</i>"))
		),
		reply_markup=kbs.kb_hent
	)


@arts.on_message(
	filters.command(commands=["milf", "–º–∏–ª—Ñ"], prefixes=["/", "!"])
)
async def milf(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	r = requests.get("https://api.waifu.im/search/?included_tags=milf").json()

	await m.delete()
	await utils.answer_photo(
		message, r['images'][0]['url'],
		"<i>–º–Ω–µ –¥–æ –Ω–µ—ë –µ—â—ë –¥–æ–ª–≥–æ —Ä–∞—Å—Ç–∏ üò©</i>", reply_markup=kbs.kb_milf,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("milf"))
async def milfCB(client: pyrogram.Client, query: types.CallbackQuery):
	r = requests.get("https://api.waifu.im/search/?included_tags=milf").json()
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=r['images'][0]['url'], has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–º–Ω–µ –¥–æ –Ω–µ—ë –µ—â—ë –¥–æ–ª–≥–æ —Ä–∞—Å—Ç–∏ üò©</i>"))
		),
		reply_markup=kbs.kb_milf
	)


@arts.on_message(
	filters.command(commands=["ecchi", "ero", "—ç—Ç—Ç–∏", "—ç—Ä–æ"], prefixes=["/", "!"])
)
async def ecchi(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	r = requests.get("https://api.waifu.im/search/?included_tags=ecchi").json()

	await m.delete()
	await utils.answer_photo(
		message, r['images'][0]['url'],
		"<i>–≤—Å—è–∫–∏–µ –ø–æ—à–ª–æ—Å—Ç–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è —Ç–µ–±—è üòè</i>", reply_markup=kbs.kb_ecchi,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("ecchi"))
async def ecchiCB(client: pyrogram.Client, query: types.CallbackQuery):
	r = requests.get("https://api.waifu.im/search/?included_tags=ecchi").json()
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=r['images'][0]['url'], has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–≤—Å—è–∫–∏–µ –ø–æ—à–ª–æ—Å—Ç–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è —Ç–µ–±—è üòè</i>"))
		),
		reply_markup=kbs.kb_ecchi
	)



@arts.on_message(
	filters.command(commands=["futa", "trap", "—Ñ—É—Ç–∞", "—Ç—Ä–∞–ø"], prefixes=["/", "!"])
)
async def trap(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	r = requests.get("https://api.waifu.pics/nsfw/trap").json()

	await m.delete()
	await utils.answer_photo(
		message, r['url'],
		"<i>–æ–Ω–∏ –±–æ–ª—å—à–∏–µ üò≥</i>", reply_markup=kbs.kb_trap,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("trap"))
async def trapCB(client: pyrogram.Client, query: types.CallbackQuery):
	r = requests.get("https://api.waifu.pics/nsfw/trap").json()
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=r['url'], has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–æ–Ω–∏ –±–æ–ª—å—à–∏–µ üò≥</i>"))
		),
		reply_markup=kbs.kb_trap
	)


@arts.on_message(
	filters.command(commands=["neko", "–Ω–µ–∫–æ"], prefixes=["/", "!"])
)
async def neko(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	r = requests.get("https://api.waifu.pics/nsfw/neko").json()

	await m.delete()
	await utils.answer_photo(
		message, r['url'],
		"<i>–∫–æ—Ç–∏–∫–∏ üòä</i>", reply_markup=kbs.kb_neko,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("neko"))
async def nekoCB(client: pyrogram.Client, query: types.CallbackQuery):
	r = requests.get("https://api.waifu.pics/nsfw/neko").json()
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=r['url'], has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–∫–æ—Ç–∏–∫–∏ üòä</i>"))
		),
		reply_markup=kbs.kb_neko
	)



@arts.on_message(
	filters.command(commands=["tentacles", "—Ç–µ–Ω—Ç–∞–∫–ª–∏"], prefixes=["/", "!"])
)
async def tentacles(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_photo(
		message, hmtai.get('hmtai', 'tentacles'),
		"<i>–æ–Ω–∏ –ª–µ–∑—É—Ç –æ—Ç–æ–≤—Å—é–¥—É üòñ</i>", reply_markup=kbs.kb_tent,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("tent"))
async def tentaclesCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=hmtai.get('hmtai', 'tentacles'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–æ–Ω–∏ –ª–µ–∑—É—Ç –æ—Ç–æ–≤—Å—é–¥—É üòñ</i>"))
		),
		reply_markup=kbs.kb_tent
	)


@arts.on_message(
	filters.command(commands=["foot", "—Ñ—É—Ç"], prefixes=["/", "!"])
)
async def footJob(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_photo(
		message, hmtai.get('hmtai', 'footjob'),
		"<i>–Ω–æ–∂–∫–∏ üòç</i>", reply_markup=kbs.kb_foot,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("foot"))
async def footJobCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=hmtai.get('hmtai', 'footjob'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–Ω–æ–∂–∫–∏ üòç</i>"))
		),
		reply_markup=kbs.kb_foot
	)


@arts.on_message(
	filters.command(commands=["orgy", "–æ—Ä–≥–∏—è"], prefixes=["/", "!"])
)
async def orgy(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_photo(
		message, hmtai.get('hmtai', 'orgy'),
		"<i>–∫–∞–∫ –º–Ω–æ–≥–æ –ª—é–¥–µ–π üôÄ</i>", reply_markup=kbs.kb_orgy,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("orgy"))
async def orgyCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=hmtai.get('hmtai', 'orgy'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–∫–∞–∫ –º–Ω–æ–≥–æ –ª—é–¥–µ–π üôÄ</i>"))
		),
		reply_markup=kbs.kb_orgy
	)


@arts.on_message(
	filters.command(commands=["bdsm", "–±–¥—Å–º"], prefixes=["/", "!"])
)
async def bdsm(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_photo(
		message, hmtai.get('hmtai', 'bdsm'),
		"<i>–ê–•~.. –µ—â—ë‚Ä¶ ü•µ</i>", reply_markup=kbs.kb_bdsm,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("bdsm"))
async def bdsmCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=hmtai.get('hmtai', 'bdsm'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–ê–•~.. –µ—â—ë‚Ä¶ ü•µ</i>"))
		),
		reply_markup=kbs.kb_bdsm
	)


@arts.on_message(
	filters.command(commands=["wallpaper", "wall", "–æ–±–æ–∏"], prefixes=["/", "!"])
)
async def wall(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_photo(
		message, hmtai.get('hmtai', 'nsfwMobileWallpaper'),
		"<i>–ª–æ–≤–∏ –æ–±–æ–∏, —Å–µ–º–ø–∞–π! üòè</i>", reply_markup=kbs.kb_wall,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("wall"))
async def wallCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=hmtai.get('hmtai', 'nsfwMobileWallpaper'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–ª–æ–≤–∏ –æ–±–æ–∏, —Å–µ–º–ø–∞–π! üòè</i>"))
		),
		reply_markup=kbs.kb_wall
	)


@arts.on_message(
	filters.command(commands=["ahegao", "–∞—Ö–µ–≥–∞–æ"], prefixes=["/", "!"])
)
async def face(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_photo(
		message, hmtai.get('hmtai', 'ahegao'),
		"<i>—ç—Ç–æ –ª–∏—á–∏–∫–æ‚Ä¶ ü§§</i>", reply_markup=kbs.kb_face,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("ahegao"))
async def faceCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=hmtai.get('hmtai', 'ahegao'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>—ç—Ç–æ –ª–∏—á–∏–∫–æ‚Ä¶ ü§§</i>"))
		),
		reply_markup=kbs.kb_face
	)


@arts.on_message(
	filters.command(commands=["gif", "–≥–∏—Ñ"], prefixes=["/", "!"])
)
async def gif(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")

	await m.delete()
	await utils.answer_anim(
		message, hmtai.get('hmtai', 'gif'),
		"<i>–ª–æ–≤–∏ –≥–∏—Ñ–∫—É, —Å–µ–º–ø–∞–π! üé•üòè</i>", reply_markup=kbs.kb_gif,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("gif"))
async def gifCB(client: pyrogram.Client, query: types.CallbackQuery):
	await utils.edit_media(
		query.message,
		types.InputMediaAnimation(
			media=hmtai.get('hmtai', 'gif'), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–ª–æ–≤–∏ –≥–∏—Ñ–∫—É, —Å–µ–º–ø–∞–π! üé•üòè</i>"))
		),
		reply_markup=kbs.kb_gif
	)



@arts.on_message(
	filters.command(commands=["furry", "yiff", "—Ñ—É—Ä—Ä–∏"], prefixes=["/", "!"])
)
async def yiff(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	links = await getScrolller("yiff")

	await m.delete()
	await utils.answer_photo(
		message, random.choice(links),
		"<i>–ª—é–±–ª—é –∑–≤–µ—Ä—É—à–µ–∫ üòó</i>", reply_markup=kbs.kb_yiff,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("yiff"))
async def yiffCB(client: pyrogram.Client, query: types.CallbackQuery):
	links = await getScrolller("yiff")

	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=random.choice(links), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–ª—é–±–ª—é –∑–≤–µ—Ä—É—à–µ–∫ üòó</i>"))
		),
		reply_markup=kbs.kb_yiff
	)


@arts.on_message(
	filters.command(commands=["yuri", "—é—Ä–∏"], prefixes=["/", "!"])
)
async def yuri(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	links = await getScrolller(
		random.choice(['yuri', 'yurihentai'])
	)

	await m.delete()
	await utils.answer_photo(
		message, random.choice(links),
		"<i>–º–∏–ª–∞—à–∫–∏ ‚ù§</i>", reply_markup=kbs.kb_yuri,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("yuri"))
async def yuriCB(client: pyrogram.Client, query: types.CallbackQuery):
	links = await getScrolller(
		random.choice(['yuri', 'yurihentai'])
	)

	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=random.choice(links), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–º–∏–ª–∞—à–∫–∏ ‚ù§</i>"))
		),
		reply_markup=kbs.kb_yuri
	)


@arts.on_message(
	filters.command(commands=["yaoi", "—è–æ–π"], prefixes=["/", "!"])
)
async def yaoi(client: pyrogram.Client, message: types.Message):
	m = await utils.answer(message, "üïì <i>–ü–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶</i>")
	links = await getScrolller(
		random.choice(["yaoi", "yaoinsfw"])
	)

	await m.delete()
	await utils.answer_photo(
		message, random.choice(links),
		"<i>–º–∞–ª—å—á–∏–∫–∏ –ø—Ä–æ—Å—Ç–æ —Ä–∞–∑–≤–ª–µ–∫–∞—é—Ç—Å—è üòè</i>", reply_markup=kbs.kb_yaoi,
		has_spoiler=True
	)

@arts.on_callback_query(filters.regex("yaoi"))
async def yaoiCB(client: pyrogram.Client, query: types.CallbackQuery):
	links = await getScrolller(
		random.choice(["yaoi", "yaoinsfw"])
	)

	await utils.edit_media(
		query.message,
		types.InputMediaPhoto(
			media=random.choice(links), has_spoiler=True,
			caption=utils.parseText(html.escape("<i>–º–∞–ª—å—á–∏–∫–∏ –ø—Ä–æ—Å—Ç–æ —Ä–∞–∑–≤–ª–µ–∫–∞—é—Ç—Å—è üòè</i>"))
		),
		reply_markup=kbs.kb_yaoi
	)